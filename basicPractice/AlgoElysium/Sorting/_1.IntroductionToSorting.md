# Introduction to Sorting

## What are Sorting Algorithms?
Sorting Algorithm in data structure are methods used to arrange data in specific order, like ascending or descending. 

The main purpose of sorting algorithm is to make data easier to work with. When data is stored, it becomes faster to search for items, easier to read, faster to process and makes implementing other algo on data much easier.


## Classification of Sort Algorithms

We can classify sorting algos as such:-

1. **Based on Comparison:**
    * *Comparison based Sorting*: These slgos sort data by comparing elements.  Example include Bubble Sort, Selection Sort, Insertion Sort, Quick Sort and Heap Sort.
    * *Non-comparison-based sorting*: These algorithm sort data without comparing elements directly. Examples include Counting SOrt, Radix SOrt, and Bucket SOrt.

2. **Based on Stability**
   * *Stable Sorting Algorithms*: Stable sort algos maintain the relative order of equal elements. Example include Bubble Sort, Merge Sort 
   * *Unstable Sorting Algorithms*: Unstable sort algos may change the relative order of equal elements. Examples include Quick Sort, Heap Sort.

---

## Common Sorting Algorithms

### 1. Bubble Sort

**Thought Process:**  
Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted.

**Analogy:**  
Imagine bubbles rising to the surface in water; larger bubbles "bubble up" to the top.

**Example:**  
Sorting `[5, 2, 9, 1]` would result in `[2, 5, 1, 9]` after the first pass.

**Pseudocode:**
```plaintext
for i from 0 to n-1
 for j from 0 to n-i-1
      if arr[j] > arr[j+1]
            swap arr[j] and arr[j+1]
```

**Where Used:**  
Simple educational purposes, small datasets.

**Why Not Used:**  
Inefficient for large datasets.

**Complexity:**  
- Time: O(n²)
- Space: O(1)

---

### 2. Selection Sort

**Thought Process:**  
Selection Sort finds the minimum element from the unsorted part and puts it at the beginning.

**Analogy:**  
Selecting the smallest card from a deck and placing it in order.

**Example:**  
Sorting `[5, 2, 9, 1]` would select `1` and place it first.

**Pseudocode:**
```plaintext
for i from 0 to n-1
 min_idx = i
 for j from i+1 to n
      if arr[j] < arr[min_idx]
            min_idx = j
 swap arr[i] and arr[min_idx]
```

**Where Used:**  
Small arrays, educational purposes.

**Why Not Used:**  
Slow for large datasets.

**Complexity:**  
- Time: O(n²)
- Space: O(1)

---

### 3. Insertion Sort

**Thought Process:**  
Insertion Sort builds the sorted array one item at a time by inserting elements into their correct position.

**Analogy:**  
Sorting playing cards in your hand.

**Example:**  
Sorting `[5, 2, 9, 1]` would insert `2` before `5`, then `1` before both.

**Pseudocode:**
```plaintext
for i from 1 to n-1
 key = arr[i]
 j = i - 1
 while j >= 0 and arr[j] > key
      arr[j+1] = arr[j]
      j = j - 1
 arr[j+1] = key
```

**Where Used:**  
Small datasets, nearly sorted data.

**Why Not Used:**  
Not efficient for large datasets.

**Complexity:**  
- Time: O(n²)
- Space: O(1)

---

### 4. Merge Sort

**Thought Process:**  
Merge Sort divides the array into halves, sorts each half, and merges them.

**Analogy:**  
Divide and conquer strategy.

**Example:**  
Sorting `[5, 2, 9, 1]` splits into `[5, 2]` and `[9, 1]`, sorts and merges.

**Pseudocode:**
```plaintext
if left < right
 mid = (left + right) / 2
 mergeSort(arr, left, mid)
 mergeSort(arr, mid+1, right)
 merge(arr, left, mid, right)
```

**Where Used:**  
Large datasets, external sorting.

**Why Not Used:**  
Requires extra space.

**Complexity:**  
- Time: O(n log n)
- Space: O(n)

---

### 5. Quick Sort

**Thought Process:**  
Quick Sort selects a pivot, partitions the array, and recursively sorts the partitions.

**Analogy:**  
Organizing books around a reference book.

**Example:**  
Sorting `[5, 2, 9, 1]` with pivot `5` results in `[2, 1]` and `[9]`.

**Pseudocode:**
```plaintext
if low < high
 pi = partition(arr, low, high)
 quickSort(arr, low, pi-1)
 quickSort(arr, pi+1, high)
```

**Where Used:**  
General-purpose sorting.

**Why Not Used:**  
Worst-case performance on already sorted data.

**Complexity:**  
- Time: O(n log n) average, O(n²) worst
- Space: O(log n)

---

### 6. Heap Sort

**Thought Process:**  
Heap Sort builds a heap and repeatedly extracts the maximum element.

**Analogy:**  
Building a pyramid and removing the top block each time.

**Example:**  
Sorting `[5, 2, 9, 1]` builds a max heap and extracts elements.

**Pseudocode:**
```plaintext
buildMaxHeap(arr)
for i from n-1 downto 1
 swap arr[0] and arr[i]
 heapify(arr, 0, i)
```

**Where Used:**  
Embedded systems, when constant space is needed.

**Why Not Used:**  
Not stable, slower than Quick Sort in practice.

**Complexity:**  
- Time: O(n log n)
- Space: O(1)

---

### 7. Counting Sort

**Thought Process:**  
Counting Sort counts the number of occurrences of each element and uses this information to place elements in order.

**Analogy:**  
Counting colored balls and arranging them.

**Example:**  
Sorting `[4, 2, 2, 8, 3]` counts occurrences and arranges.

**Pseudocode:**
```plaintext
find max value in arr
create count array of size max+1
for each element in arr
 increment count[element]
for i from 1 to max
 count[i] += count[i-1]
for each element in arr (reverse order)
 output[count[element]-1] = element
 count[element] -= 1
```

**Where Used:**  
Sorting integers in a limited range.

**Why Not Used:**  
Not suitable for large ranges or non-integer data.

**Complexity:**  
- Time: O(n + k)
- Space: O(k)

---

### 8. Radix Sort

**Thought Process:**  
Radix Sort sorts numbers digit by digit, starting from least significant digit.

**Analogy:**  
Sorting numbers by each digit column.

**Example:**  
Sorting `[170, 45, 75, 90]` sorts by units, then tens, then hundreds.

**Pseudocode:**
```plaintext
for digit position from least to most significant
 sort elements by current digit using stable sort
```

**Where Used:**  
Large lists of integers, strings.

**Why Not Used:**  
Not suitable for floating-point numbers or variable-length data.

**Complexity:**  
- Time: O(nk)
- Space: O(n + k)

---

### 9. Bucket Sort

**Thought Process:**  
Bucket Sort distributes elements into buckets, sorts each bucket, and concatenates them.

**Analogy:**  
Sorting coins into buckets by value, then sorting each bucket.

**Example:**  
Sorting `[0.42, 4.21, 3.14, 2.71]` into buckets by range.

**Pseudocode:**
```plaintext
create k empty buckets
for each element in arr
 insert element into appropriate bucket
sort each bucket
concatenate all buckets
```

**Where Used:**  
Uniformly distributed data.

**Why Not Used:**  
Performance depends on data distribution.

**Complexity:**  
- Time: O(n + k)
- Space: O(n + k)

---

### 10. TimSort

**Thought Process:**  
TimSort is a hybrid sorting algorithm combining Merge Sort and Insertion Sort. It divides the array into small runs, sorts them using Insertion Sort, and then merges runs using Merge Sort.

**Analogy:**  
Sorting small piles of papers, then merging sorted piles.

**Example:**  
Sorting `[5, 2, 9, 1, 7, 6]` splits into runs, sorts each, and merges.

**Pseudocode:**
```plaintext
identify runs in array
sort each run using insertion sort
merge runs using merge sort
```

**Where Used:**  
Default sort in Python, Java, Android.

**Why Used:**  
Efficient for real-world data, stable, adaptive.

**Complexity:**  
- Time: O(n log n)
- Space: O(n)

---

## Modern Sorting Practices

- **Use Built-in Sorts:** Most languages provide optimized, stable sorting functions (e.g., `Arrays.sort()` in Java, `sorted()` in Python).
- **Choose Algorithm Based on Data:** For small or nearly sorted data, Insertion Sort or TimSort is preferred. For large, random data, Quick Sort or Merge Sort is common.
- **Consider Stability:** Stable sorts are important when the relative order of equal elements matters.
- **Parallel and External Sorting:** For huge datasets, use parallel algorithms or external sorting techniques.
- **Leverage Libraries:** Use trusted libraries for performance and reliability instead of implementing from scratch unless learning or for special needs.

---